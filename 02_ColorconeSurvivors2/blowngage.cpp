//=========================================================================================
//
//[blowngage.cpp]
//Author:日野澤匠泉
//
//=========================================================================================

//*****************************************************************************************
//インクルード
//*****************************************************************************************
#include "blowngage.h"
#include "manager.h"
#include "renderer.h"
#include "object2d.h"
#include "blown.h"

//*****************************************************************************************
//静的メンバ変数初期化
//*****************************************************************************************
LPDIRECT3DTEXTURE9 CBlowngage::m_pTexture = nullptr;

//=========================================================================================
//ぶっ飛びゲージのコンストラクタ
//=========================================================================================
CBlowngage::CBlowngage()
{
	m_pObject2D = nullptr;
}

//=========================================================================================
//ぶっ飛びゲージのデストラクタ
//=========================================================================================
CBlowngage::~CBlowngage()
{

}

//=========================================================================================
//ぶっ飛びゲージのテクスチャ読み込み
//=========================================================================================
HRESULT CBlowngage::Load(void)
{
	//オブジェクト取得
	CRenderer* pRenderer = CManager::GetManager()->GetRenderer();

	//デバイス取得
	LPDIRECT3DDEVICE9 pDevice = pRenderer->GetDevice();

	//テクスチャの読み込み
	D3DXCreateTextureFromFile(pDevice,
		"data\\TEXTURE\\blowngage.png",
		&m_pTexture);

	return S_OK;
}

//=========================================================================================
//ぶっ飛びゲージのテクスチャ破棄
//=========================================================================================
void CBlowngage::Unload(void)
{
	//テクスチャの破棄
	if (m_pTexture != nullptr)
	{
		m_pTexture->Release();
		m_pTexture = nullptr;
	}
}

//=========================================================================================
//ぶっ飛びゲージの初期化処理
//=========================================================================================
HRESULT CBlowngage::Init(void)
{
	//オブジェクト生成
	m_pObject2D = CObject2D::Create();

	return S_OK;
}

//=========================================================================================
//ぶっ飛びゲージの終了処理
//=========================================================================================
void CBlowngage::Uninit(void)
{
	if (m_pObject2D != nullptr)
	{//使用されているとき

		//使用されていない状態にする
		m_pObject2D = nullptr;
	}
}

//=========================================================================================
//ぶっ飛びゲージの更新処理
//=========================================================================================
void CBlowngage::Update(void)
{

}

//=========================================================================================
//ぶっ飛びゲージの描画処理
//=========================================================================================
void CBlowngage::Draw(void)
{

}

//=========================================================================================
//ぶっ飛びゲージの設定処理
//=========================================================================================
CBlowngage* CBlowngage::Create(void)
{
	//ポインタの変数を宣言
	CBlowngage* pNumber;

	//オブジェクト2Dの生成
	pNumber = new CBlowngage;

	if (pNumber != nullptr)
	{//使用されているとき

		//初期化処理
		pNumber->Init();

		//テクスチャの割り当て
		pNumber->m_pObject2D->BindTexture(m_pTexture);
	}

	//オブジェクト情報を返す
	return pNumber;
}

//=========================================================================================
//ぶっ飛びゲージの設定処理
//=========================================================================================
void CBlowngage::SetScore(D3DXVECTOR3 pos, int nCnt, int aTexU)
{
	VERTEX_2D* pVtx;

	//頂点バッファをロックし、頂点データへのポインタを取得
	m_pObject2D->GetVtx()->Lock(0, 0, (void**)&pVtx, 0);

	//位置を更新
	pVtx[0].pos = D3DXVECTOR3(pos.x - 25.0f + nCnt * 50.0f, pos.y, 0.0f);
	pVtx[1].pos = D3DXVECTOR3(pos.x + 25.0f + nCnt * 50.0f, pos.y, 0.0f);
	pVtx[2].pos = D3DXVECTOR3(pos.x - 25.0f + nCnt * 50.0f, pos.y + 50.0f, 0.0f);
	pVtx[3].pos = D3DXVECTOR3(pos.x + 25.0f + nCnt * 50.0f, pos.y + 50.0f, 0.0f);

	//テクスチャ座標の更新
	pVtx[0].tex = D3DXVECTOR2(0.0f + aTexU * 0.1f, 0.0f);
	pVtx[1].tex = D3DXVECTOR2(0.1f + aTexU * 0.1f, 0.0f);
	pVtx[2].tex = D3DXVECTOR2(0.0f + aTexU * 0.1f, 1.0f);
	pVtx[3].tex = D3DXVECTOR2(0.1f + aTexU * 0.1f, 1.0f);

	//頂点バッファをアンロックする
	m_pObject2D->GetVtx()->Unlock();
}

//=========================================================================================
//ぶっ飛びゲージの加算処理
//=========================================================================================
void CBlowngage::AddScore(int nCnt, int aTexU)
{
	VERTEX_2D* pVtx;

	//頂点バッファをロックし、頂点データへのポインタを取得
	m_pObject2D->GetVtx()->Lock(0, 0, (void**)&pVtx, 0);

	//位置を更新
	pVtx[0].pos = D3DXVECTOR3(100.0f + nCnt * 50.0f, 0.0f, 0.0f);
	pVtx[1].pos = D3DXVECTOR3(150.0f + nCnt * 50.0f, 0.0f, 0.0f);
	pVtx[2].pos = D3DXVECTOR3(100.0f + nCnt * 50.0f, 50.0f, 0.0f);
	pVtx[3].pos = D3DXVECTOR3(150.0f + nCnt * 50.0f, 50.0f, 0.0f);

	//テクスチャ座標の更新
	pVtx[0].tex = D3DXVECTOR2(0.0f + aTexU * 0.1f, 0.0f);
	pVtx[1].tex = D3DXVECTOR2(0.1f + aTexU * 0.1f, 0.0f);
	pVtx[2].tex = D3DXVECTOR2(0.0f + aTexU * 0.1f, 1.0f);
	pVtx[3].tex = D3DXVECTOR2(0.1f + aTexU * 0.1f, 1.0f);

	//頂点バッファをアンロックする
	m_pObject2D->GetVtx()->Unlock();
}

//=========================================================================================
//色の設定
//=========================================================================================
void CBlowngage::SetCol(D3DXCOLOR col)
{
	VERTEX_2D* pVtx;

	//頂点バッファをロックし、頂点データへのポインタを取得
	m_pObject2D->GetVtx()->Lock(0, 0, (void**)&pVtx, 0);

	//位置を更新
	pVtx[0].col = D3DXCOLOR(col.r,col.g,col.b,col.a);
	pVtx[1].col = D3DXCOLOR(col.r,col.g,col.b,col.a);
	pVtx[2].col = D3DXCOLOR(col.r,col.g,col.b,col.a);
	pVtx[3].col = D3DXCOLOR(col.r,col.g,col.b,col.a);

	//頂点バッファをアンロックする
	m_pObject2D->GetVtx()->Unlock();
}